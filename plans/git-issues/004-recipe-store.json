{
  "number": 4,
  "title": "Recipe store: full SQLite DAL with CRUD and fuzzy matching",
  "state": "open",
  "labels": [
    {"name": "phase:2-core"},
    {"name": "priority:P0"},
    {"name": "component:backend"}
  ],
  "milestone": {"title": "Phase 2: Replace Stubs"},
  "body": "## Summary\n\nReplace the stub `recipe_store.py` with a full SQLite data access layer. This is the persistence backbone — recipes, pantry staples, preferences, and brand preferences all live here.\n\n## Context\n\nEvery other module reads or writes through RecipeStore. The meal parser checks for known recipes here. The consolidator reads pantry staples from here. The web dashboard and Discord bot both do CRUD through here. This must be solid.\n\n## Acceptance Criteria\n\n### RecipeStore class\n\nConstructor:\n- [ ] `__init__(self, db_path: str)` — stores path, calls `init_db()` on first use\n- [ ] Connection management: create connection per operation, use context managers, WAL mode enabled\n\n### Recipe CRUD\n- [ ] `save_recipe(meal: ParsedMeal) -> int` — insert into `recipes` + `recipe_ingredients`, return recipe id. Normalize name (see below). Use transaction.\n- [ ] `get_recipe(name: str) -> ParsedMeal | None` — lookup by normalized name, return as Pydantic model\n- [ ] `get_recipe_by_id(recipe_id: int) -> ParsedMeal | None`\n- [ ] `update_recipe(recipe_id: int, meal: ParsedMeal) -> None` — replace ingredients (delete + re-insert in transaction)\n- [ ] `delete_recipe(recipe_id: int) -> None`\n- [ ] `list_recipes() -> list[dict]` — return `[{\"id\": 1, \"name\": \"...\", \"display_name\": \"...\", \"times_ordered\": N}, ...]`\n- [ ] `export_recipe_json(recipe_id: int) -> str` — JSON string suitable for passing to Claude as context\n- [ ] `increment_times_ordered(recipe_id: int) -> None`\n\n### Recipe name normalization\n- [ ] Function `normalize_recipe_name(name: str) -> str`\n- [ ] Lowercase\n- [ ] Strip leading articles (\"a \", \"an \", \"the \")\n- [ ] Normalize possessives (\"mom's\" -> \"moms\")\n- [ ] Remove punctuation\n- [ ] Collapse whitespace\n- [ ] Example: `\"Mom's Chicken Tikka Masala\"` -> `\"moms chicken tikka masala\"`\n\n### Fuzzy recipe lookup\n- [ ] `find_recipe(query: str) -> ParsedMeal | None` — try exact normalized match first, then substring match, then return None\n- [ ] Return the best match or None (Claude-based fuzzy matching happens in meal_parser, not here)\n\n### Pantry staples CRUD\n- [ ] `get_pantry_staples() -> list[dict]` — returns `[{\"id\": 1, \"ingredient\": \"salt\", \"display_name\": \"Salt\", \"category\": \"pantry_dry\"}, ...]`\n- [ ] `get_pantry_staple_names() -> list[str]` — just the ingredient names (for prompt context)\n- [ ] `add_pantry_staple(ingredient: str, category: str) -> int`\n- [ ] `remove_pantry_staple(staple_id: int) -> None`\n- [ ] `is_pantry_staple(ingredient: str) -> bool`\n\n### Preferences CRUD\n- [ ] `get_preference(key: str) -> str | None`\n- [ ] `set_preference(key: str, value: str) -> None` — upsert\n- [ ] `get_all_preferences() -> dict[str, str]`\n\n### Brand preferences CRUD\n- [ ] `get_brand_preferences() -> list[BrandPreference]`\n- [ ] `add_brand_preference(pref: BrandPreference) -> int`\n- [ ] `remove_brand_preference(pref_id: int) -> None`\n- [ ] `get_brands_for_ingredient(ingredient: str) -> list[BrandPreference]` — check ingredient-level first, fall back to category-level\n\n### Tests (tests/test_recipe_store.py)\n- [ ] Test recipe CRUD lifecycle (create, read, update, delete)\n- [ ] Test name normalization edge cases\n- [ ] Test fuzzy matching (exact, substring, no match)\n- [ ] Test pantry staple CRUD\n- [ ] Test preference upsert behavior\n- [ ] Test brand preference with ingredient-level override of category-level\n- [ ] Use in-memory SQLite (`:memory:`) or temp file for test isolation\n\n## Key Design Decisions\n\n- Synchronous SQLite (not aiosqlite) for RecipeStore — the async is only needed for the Discord bot, and we can run sync DB calls in an executor there\n- All methods return Pydantic models or plain dicts, never raw sqlite3.Row\n- Transactions for multi-table operations (save_recipe touches 2 tables)\n\n## Blocked By\n\n#1 (foundation — needs schema.sql and models.py)\n\n## Blocks\n\n#6 (meal parser checks recipe memory), #8 (web dashboard reads/writes recipes)"
}
