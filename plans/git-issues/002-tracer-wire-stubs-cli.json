{
  "number": 2,
  "title": "Tracer wire: stub all modules and CLI end-to-end pipeline",
  "state": "open",
  "labels": [
    {"name": "phase:1-tracer"},
    {"name": "priority:P0"},
    {"name": "component:backend"}
  ],
  "milestone": {"title": "Phase 1: Wire the Skeleton"},
  "body": "## Summary\n\nCreate stub versions of every module and a CLI that wires them together into a working end-to-end pipeline. After this issue, `python cli.py plan \"tacos, pasta\"` returns a hardcoded but structurally correct shopping list.\n\nThis is the tracer bullet. From this point forward, every issue replaces a stub with real logic — the system is always demoable.\n\n## Context\n\nTracer-code principle: wire the thinnest possible path through the entire system first. Each stub returns hardcoded data that matches the real Pydantic model shapes. The CLI proves all modules connect.\n\n## Acceptance Criteria\n\n### Stub modules (return hardcoded data, correct types)\n\n#### grocery_butler/recipe_store.py\n- [ ] Class `RecipeStore` with constructor taking `db_path: str`\n- [ ] `get_recipe(name: str) -> ParsedMeal | None` — returns `None` (no recipes yet)\n- [ ] `save_recipe(meal: ParsedMeal) -> None` — no-op\n- [ ] `list_recipes() -> list[str]` — returns `[]`\n- [ ] `get_pantry_staples() -> list[str]` — returns hardcoded `DEFAULT_PANTRY` names\n- [ ] `get_preferences() -> dict` — returns hardcoded defaults\n- [ ] `get_brand_preferences() -> list[BrandPreference]` — returns `[]`\n\n#### grocery_butler/pantry_manager.py\n- [ ] Class `PantryManager` with constructor taking `db_path: str`\n- [ ] `get_restock_queue() -> list[InventoryItem]` — returns `[]`\n- [ ] `get_inventory() -> list[InventoryItem]` — returns `[]`\n- [ ] `update_status(ingredient: str, status: InventoryStatus) -> None` — no-op\n- [ ] `parse_inventory_intent(message: str) -> list[InventoryUpdate]` — returns `[]`\n\n#### grocery_butler/meal_parser.py\n- [ ] Class `MealParser` with constructor taking `recipe_store: RecipeStore`\n- [ ] `parse_meals(meal_names: list[str], servings: int) -> list[ParsedMeal]` — returns hardcoded `ParsedMeal` for each input with 2-3 dummy ingredients\n- [ ] Hardcoded response should be structurally realistic (chicken thighs for \"tacos\", etc.)\n\n#### grocery_butler/consolidator.py\n- [ ] Class `Consolidator`\n- [ ] `consolidate(meals: list[ParsedMeal], restock: list[InventoryItem], pantry: list[str]) -> list[ShoppingListItem]` — flattens all `purchase_items` into `ShoppingListItem` list with `search_term` populated\n\n### CLI (grocery_butler/cli.py)\n- [ ] Uses `argparse` or simple arg parsing\n- [ ] `python -m grocery_butler.cli plan \"chicken tikka masala, caesar salad\"` — runs full pipeline, prints shopping list to stdout as formatted table\n- [ ] `python -m grocery_butler.cli stock` — prints inventory (empty for now)\n- [ ] `python -m grocery_butler.cli stock out \"soy sauce\"` — prints confirmation (no-op for now)\n- [ ] `python -m grocery_butler.cli restock` — prints restock queue (empty for now)\n- [ ] Pipeline wiring: `cli -> meal_parser -> consolidator -> print`, with `recipe_store` and `pantry_manager` injected\n- [ ] Exit code 0 on success\n\n### Smoke test\n- [ ] `tests/test_smoke.py` — one test that runs the CLI `plan` command and asserts it returns a non-empty list of `ShoppingListItem`\n\n## Gate Check\n\n```bash\npython -m grocery_butler.cli plan \"tacos, pasta\"\n```\n\nShould print something like:\n```\nShopping List (2 meals, 6 items):\n──────────────────────────────────\n  MEAT\n    chicken thighs, boneless    2.0 lbs    [tacos]\n  PRODUCE\n    roma tomatoes               6.0 each   [tacos, pasta]\n    ...\n```\n\nIf the clock stopped here, we'd have a working (stubbed) app to demo.\n\n## File Inventory\n\n```\ngrocery_butler/\n├── recipe_store.py      (stub)\n├── pantry_manager.py    (stub)\n├── meal_parser.py       (stub)\n├── consolidator.py      (stub)\n├── cli.py\ntests/\n└── test_smoke.py\n```\n\n## Blocked By\n\n#1 (foundation)\n\n## Blocks\n\n#4, #5, #6, #7 (all real implementations replace these stubs)"
}
