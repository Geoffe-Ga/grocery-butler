{
  "number": 6,
  "title": "Meal parser: Claude-powered meal decomposition with recipe memory",
  "state": "open",
  "labels": [
    {"name": "phase:2-core"},
    {"name": "priority:P0"},
    {"name": "component:backend"}
  ],
  "milestone": {"title": "Phase 2: Replace Stubs"},
  "body": "## Summary\n\nReplace the stub `meal_parser.py` with real Claude API integration. This is the core intelligence — it takes meal names like \"chicken tikka masala\" and produces structured ingredient lists.\n\n## Context\n\nThe meal parser is the entry point to the pipeline. For each meal name:\n1. Check recipe memory first (RecipeStore fuzzy lookup)\n2. If found: return stored recipe, optionally adjust for serving size via Claude\n3. If not found: call Claude with `meal_decomposition.txt` prompt to generate ingredients\n4. For near-matches: use `recipe_matching.txt` prompt as fallback\n5. Flag unknown recipes with `needs_confirmation: true`\n\n## Acceptance Criteria\n\n### MealParser class\n\nConstructor:\n- [ ] `__init__(self, recipe_store: RecipeStore, anthropic_client, config)` — inject dependencies\n\n### Core method\n- [ ] `parse_meals(meal_names: list[str], servings: int | None = None) -> list[ParsedMeal]`\n- [ ] For each meal name:\n  1. Normalize the name\n  2. Check `recipe_store.find_recipe(name)` for exact/substring match\n  3. If no match: try Claude fuzzy matching via `recipe_matching.txt` against `recipe_store.list_recipes()`\n  4. If known recipe found: return it (adjust serving size if `servings` differs from `default_servings`)\n  5. If unknown: call Claude with `meal_decomposition.txt`, flag `needs_confirmation=True`\n- [ ] Returns list of ParsedMeal, one per input meal name\n\n### Recipe name normalization\n- [ ] `normalize_name(name: str) -> str` — reuse or import from recipe_store\n- [ ] Lowercase, strip articles, normalize possessives, remove punctuation, collapse whitespace\n\n### Claude API integration\n- [ ] Use `anthropic` SDK, `messages.create()` with model from config\n- [ ] Load prompts via `prompt_loader.load_prompt()`\n- [ ] Format prompts with context: `default_servings`, `pantry_staples`, `known_recipes`, `units` from config/recipe_store\n- [ ] Parse Claude's JSON response into `list[ParsedMeal]` via Pydantic\n- [ ] Retry once on invalid JSON (append \"Your previous response was not valid JSON. Please try again, outputting ONLY valid JSON.\")\n- [ ] `try/except` with exponential backoff (1 retry)\n\n### Recipe learning\n- [ ] After successful Claude parse of unknown meal: optionally save to recipe_store (controlled by a `save=True` parameter)\n- [ ] `save_parsed_meal(meal: ParsedMeal) -> None` — delegates to `recipe_store.save_recipe()`\n\n### Tests (tests/test_meal_parser.py)\n- [ ] Test known recipe returns stored data without Claude call\n- [ ] Test unknown recipe calls Claude and returns ParsedMeal with `needs_confirmation=True`\n- [ ] Test Claude response parsing — mock client returns valid JSON, verify Pydantic models\n- [ ] Test Claude invalid JSON retry — mock returns garbage first, valid JSON second\n- [ ] Test recipe name normalization edge cases\n- [ ] Test fuzzy matching via recipe_matching prompt (mock Claude)\n- [ ] Test serving size adjustment\n- [ ] All tests mock the Anthropic client — no real API calls\n\n## Error Handling\n\n- Claude API timeout/error: return error message, don't crash\n- Invalid JSON from Claude: retry once, then raise with context\n- Empty meal list: return empty list\n\n## Blocked By\n\n#1 (models), #3 (prompt templates), #4 (recipe store — needed for recipe lookup)\n\n## Blocks\n\n#7 (consolidator consumes ParsedMeal output)"
}
